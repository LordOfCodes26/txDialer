package com.android.dialer.helpers

// File: CryptoUtils.kt
import android.os.Build
import android.security.keystore.KeyGenParameterSpec
import android.security.keystore.KeyProperties
import androidx.annotation.RequiresApi
import java.io.File
import java.io.FileInputStream
import java.io.FileOutputStream
import java.security.KeyFactory
import java.security.KeyPairGenerator
import java.security.KeyStore
import java.security.spec.X509EncodedKeySpec
import javax.crypto.Cipher
import javax.crypto.CipherInputStream
import javax.crypto.CipherOutputStream
import javax.crypto.KeyGenerator
import javax.crypto.SecretKey
import javax.crypto.spec.GCMParameterSpec
import javax.crypto.spec.SecretKeySpec
import kotlin.random.Random

object CryptoUtils {
    private const val ANDROID_KEYSTORE = "AndroidKeyStore"

    // AES config
    private const val AES_ALGORITHM = "AES"
    private const val AES_TRANSFORMATION = "AES/GCM/NoPadding"
    private const val GCM_TAG_LENGTH = 128 // bits
    private const val IV_SIZE = 12 // 12 bytes recommended for GCM

    // RSA / KeyWrap config (for wrapping AES key)
    private const val RSA_ALGORITHM = "RSA"
    private const val RSA_TRANSFORMATION = "RSA/ECB/OAEPWithSHA-256AndMGF1Padding"
    private const val RSA_KEY_SIZE = 2048

    // buffer for streaming
    private const val BUFFER_SIZE = 16 * 1024

    /** Generate a new random AES-256 key. */
    fun generateAesKey(): SecretKey {
        val kg = KeyGenerator.getInstance(AES_ALGORITHM)
        kg.init(256)
        return kg.generateKey()
    }

    /**
     * Encrypt a file (streaming). Output file layout:
     *   [12 bytes IV][ciphertext]
     */
    fun encryptFileAESGCM(aesKey: SecretKey, inputFile: File, outputFile: File) {
        val iv = ByteArray(IV_SIZE)
        Random.nextBytes(iv)

        val cipher = Cipher.getInstance(AES_TRANSFORMATION)
        val gcmSpec = GCMParameterSpec(GCM_TAG_LENGTH, iv)
        cipher.init(Cipher.ENCRYPT_MODE, aesKey, gcmSpec)

        FileInputStream(inputFile).use { fis ->
            FileOutputStream(outputFile).use { fos ->
                // write IV first
                fos.write(iv)
                CipherOutputStream(fos, cipher).use { cos ->
                    val buffer = ByteArray(BUFFER_SIZE)
                    var read: Int
                    while (fis.read(buffer).also { read = it } != -1) {
                        cos.write(buffer, 0, read)
                    }
                }
            }
        }
    }

    /**
     * Decrypt file produced by encryptFileAESGCM.
     * Expects the IV to be the first 12 bytes.
     */
    fun decryptFileAESGCM(aesKey: SecretKey, inputFile: File, outputFile: File) {
        FileInputStream(inputFile).use { fis ->
            val iv = ByteArray(IV_SIZE)
            val got = fis.read(iv)
            if (got != IV_SIZE) throw IllegalArgumentException("Invalid encrypted file (IV missing)")

            val cipher = Cipher.getInstance(AES_TRANSFORMATION)
            val gcmSpec = GCMParameterSpec(GCM_TAG_LENGTH, iv)
            cipher.init(Cipher.DECRYPT_MODE, aesKey, gcmSpec)

            CipherInputStream(fis, cipher).use { cis ->
                FileOutputStream(outputFile).use { fos ->
                    val buffer = ByteArray(BUFFER_SIZE)
                    var read: Int
                    while (cis.read(buffer).also { read = it } != -1) {
                        fos.write(buffer, 0, read)
                    }
                }
            }
        }
    }

    /** Convert SecretKey to bytes (for wrapping) */
    fun secretKeyToBytes(key: SecretKey): ByteArray {
        return key.encoded // For AES keys generated by KeyGenerator this works
    }

    /** Restore SecretKey from bytes */
    fun bytesToSecretKey(bytes: ByteArray): SecretKey {
        return SecretKeySpec(bytes, AES_ALGORITHM)
    }

    // ===== RSA keypair in Android Keystore (per-device) =====

    /**
     * Ensure an RSA keypair with alias exists in Android Keystore.
     * The private key will stay in Keystore and be non-exportable.
     */
    @RequiresApi(Build.VERSION_CODES.P)
    fun ensureRSAKeyPair(alias: String) {
        val ks = KeyStore.getInstance(ANDROID_KEYSTORE).apply { load(null) }

        // If key already exists, nothing to do
        if (!ks.containsAlias(alias)) {
            val kpg = KeyPairGenerator.getInstance(
                KeyProperties.KEY_ALGORITHM_RSA, ANDROID_KEYSTORE
            )

            val spec = KeyGenParameterSpec.Builder(
                alias,
                KeyProperties.PURPOSE_ENCRYPT or KeyProperties.PURPOSE_DECRYPT or KeyProperties.PURPOSE_WRAP_KEY
            )
                .setKeySize(RSA_KEY_SIZE)
                .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_RSA_OAEP)
                .setDigests(KeyProperties.DIGEST_SHA256, KeyProperties.DIGEST_SHA512)
                .setUserAuthenticationRequired(false)
                .build()

            kpg.initialize(spec)
            kpg.generateKeyPair()
        }
    }

    /** Get the public key bytes for an alias (to export to other devices). */
    fun getRSAPublicKeyBytes(alias: String): ByteArray {
        val ks = KeyStore.getInstance(ANDROID_KEYSTORE).apply { load(null) }
        val cert = ks.getCertificate(alias) ?: throw IllegalStateException("No certificate for $alias")
        return cert.publicKey.encoded
    }

    /** Wrap (encrypt) AES key bytes with RSA public key (OAEP). Use for export. */
    fun wrapAesKeyWithRsaPublicKey(aesKey: SecretKey, rsaPublicKeyBytes: ByteArray): ByteArray {
        val kf = KeyFactory.getInstance("RSA")
        val pubSpec = X509EncodedKeySpec(rsaPublicKeyBytes)
        val pub = kf.generatePublic(pubSpec)

        val cipher = Cipher.getInstance(RSA_TRANSFORMATION)
        cipher.init(Cipher.ENCRYPT_MODE, pub)
        val wrapped = cipher.doFinal(secretKeyToBytes(aesKey))
        return wrapped
    }

    /** Unwrap RSA-wrapped AES key using the private key in Android Keystore (alias). */
    fun unwrapAesKeyWithKeystorePrivate(alias: String, wrappedKey: ByteArray): SecretKey {
        val ks = KeyStore.getInstance(ANDROID_KEYSTORE).apply { load(null) }
        val privateKey = ks.getKey(alias, null) ?: throw IllegalStateException("No private key for $alias")
        val cipher = Cipher.getInstance(RSA_TRANSFORMATION)
        cipher.init(Cipher.DECRYPT_MODE, privateKey)
        val keyBytes = cipher.doFinal(wrappedKey)
        return bytesToSecretKey(keyBytes)
    }

    /**
     * Wrap AES key using RSA private key stored in Keystore (alternate: use wrap/unwrap ops if you want).
     * Not usually needed; usually you wrap with recipient's public key.
     */

    // Convenience helpers to save/load wrapped key file
    fun saveBytesToFile(bytes: ByteArray, outFile: File) {
        FileOutputStream(outFile).use { it.write(bytes) }
    }

    fun readBytesFromFile(file: File): ByteArray {
        return file.readBytes()
    }
}
